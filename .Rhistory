#error rate
print(paste0("Algorithm error rate: ",
round((1-(length(identifiedCACTA[,1])/length(potentialPacks[,1]))) * 100, 2),
"%"))
return(knownCACTA)
}
getknownTIRs <- function(knownCACTA) {
return(DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)))
}
assessSubSeq <- function(subSeq, knownTIRs, mismatch = 0) {
successfulMatches <- vector(mode = "logical", length = length(knownTIRs))
for(i in 1:length(knownTIRs)) {
if(countPattern(subSeq, knownTIRs[[i]], max.mismatch = mismatch, with.indels = TRUE) > 0) {
successfulMatches[i] <- TRUE
}
}
return(successfulMatches)
}
getBadMatches <- function(knownCACTA, subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
badCACTA <- knownCACTA[0,]
for(bad in 1:length(badMatches)) {
if(badMatches[bad] > 10) {
badMatches[bad] <- badMatches[bad] - 10
}
badCACTA <- rbind(badCACTA, knownCACTA[badMatches[bad],])
}
return(badCACTA)
}
getBadSeqs <- function(subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
return(knownTIRs[badMatches])
}
saveReport <- function(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0) {
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20]) %>%
rename(Chr = "chr") %>%
select(-c(TAIR10.annotations, blast.best.hits, mobilization, chrNames)) %>%
write.csv(file = "Results/algorithmReport.csv")
return(knownCACTA)
}
# useful functions for manipulating and assessing other functions within the pack-TYPE
# transposon finding project
initialise <- function() {
# Loads the ArAth genome and required packages for testing
#
# ---returns---
# Arabidopsis thalania genome (as Biostrings::DNAStringSet)
library(Biostrings)
library(biomartr)
library(GenomicRanges)
library(dplyr)
Genome <- read_genome(getGenome(db = "refseq", "Arabidopsis thaliana", path = "/Input"))
return(Genome[1:5])
}
getArAthCACTA <- function(Genome, integrityFilter = NULL) {
# gets the ArAth packCACTA sequences
#
# ---input---
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# dataframe containing sequence information from the known ArAth CACTA sequences
knownCACTA <- read.csv("Input/knownCACTA.csv", sep = ";") %>%
mutate(TSD = gsub("\\*", "", TSD)) %>%
mutate(chrNames = Genome@ranges@NAMES[Chr]) %>%
mutate(forwardTIR = mapply(function(Chr, start, Genome) {
return(Genome[[Chr]][start:(start+25)])},
Chr,
start,
MoreArgs = list(Genome = Genome))) %>%
mutate(reverseTIR = mapply(function(Chr, end, Genome) {
return(reverseComplement(Genome[[Chr]][(end-25):end]))},
Chr,
end,
MoreArgs = list(Genome = Genome)))
if (is.null(integrityFilter)) {
return(knownCACTA)
} else if (integrityFilter == "complete") {
filter(knownCACTA, integrity == integrityFilter) %>%
return()
} else if (integrityFilter == "not partial") {
filter(knownCACTA, integrity != "partial") %>%
return()
}
}
algorithmAssessment <- function(potentialPacks, Genome, integrityFilter = "complete") {
# Assesses the error rate of the Pack-TYPE transposon finding algorithm
#
# ---input---
# potentialPacks: a list of identified potential transposons
# Genome: a DNAStringSet object containing the genome being searched
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# prints: error rate of algorithm based on known transposons
# returns: a list of correctly identified transposons
knownCACTA <- getArAthCACTA(Genome, integrityFilter) %>%
mutate(identified = start %in% potentialPacks$start & end %in% potentialPacks$end) #does not consider chromosome
#number identified
print(paste0("Correct packCACTA identified in Arabidopsis thalania: ",
(length(identifiedCACTA[,1])),
"/",
length(knownCACTA[,1])))
#detection rate
print(paste0("packCACTA detection rate: ",
round((length(identifiedCACTA[,1])/length(knownCACTA[,1])) * 100, 2),
"%"))
#error rate
print(paste0("Algorithm error rate: ",
round((1-(length(identifiedCACTA[,1])/length(potentialPacks[,1]))) * 100, 2),
"%"))
return(knownCACTA)
}
getknownTIRs <- function(knownCACTA) {
return(DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)))
}
assessSubSeq <- function(subSeq, knownTIRs, mismatch = 0) {
successfulMatches <- vector(mode = "logical", length = length(knownTIRs))
for(i in 1:length(knownTIRs)) {
if(countPattern(subSeq, knownTIRs[[i]], max.mismatch = mismatch, with.indels = TRUE) > 0) {
successfulMatches[i] <- TRUE
}
}
return(successfulMatches)
}
getBadMatches <- function(knownCACTA, subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
badCACTA <- knownCACTA[0,]
for(bad in 1:length(badMatches)) {
if(badMatches[bad] > 10) {
badMatches[bad] <- badMatches[bad] - 10
}
badCACTA <- rbind(badCACTA, knownCACTA[badMatches[bad],])
}
return(badCACTA)
}
getBadSeqs <- function(subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
return(knownTIRs[badMatches])
}
saveReport <- function(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0) {
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20]) %>%
rename(Chr = "chr") %>%
select(-c(TAIR10.annotations, blast.best.hits, mobilization, chrNames)) %>%
write.csv(file = "Results/algorithmReport.csv")
return(knownCACTA)
}
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]]))
View(knownCACTA)
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20])
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20])
mismatch = 2
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20])
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20])
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
View(knownCACTA)
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
# useful functions for manipulating and assessing other functions within the pack-TYPE
# transposon finding project
initialise <- function() {
# Loads the ArAth genome and required packages for testing
#
# ---returns---
# Arabidopsis thalania genome (as Biostrings::DNAStringSet)
library(Biostrings)
library(biomartr)
library(GenomicRanges)
library(dplyr)
Genome <- read_genome(getGenome(db = "refseq", "Arabidopsis thaliana", path = "/Input"))
return(Genome[1:5])
}
getArAthCACTA <- function(Genome, integrityFilter = NULL) {
# gets the ArAth packCACTA sequences
#
# ---input---
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# dataframe containing sequence information from the known ArAth CACTA sequences
knownCACTA <- read.csv("Input/knownCACTA.csv", sep = ";") %>%
mutate(TSD = gsub("\\*", "", TSD)) %>%
mutate(chrNames = Genome@ranges@NAMES[Chr]) %>%
mutate(forwardTIR = mapply(function(Chr, start, Genome) {
return(Genome[[Chr]][start:(start+25)])},
Chr,
start,
MoreArgs = list(Genome = Genome))) %>%
mutate(reverseTIR = mapply(function(Chr, end, Genome) {
return(reverseComplement(Genome[[Chr]][(end-25):end]))},
Chr,
end,
MoreArgs = list(Genome = Genome)))
if (is.null(integrityFilter)) {
return(knownCACTA)
} else if (integrityFilter == "complete") {
filter(knownCACTA, integrity == integrityFilter) %>%
return()
} else if (integrityFilter == "not partial") {
filter(knownCACTA, integrity != "partial") %>%
return()
}
}
algorithmAssessment <- function(potentialPacks, Genome, integrityFilter = "complete") {
# Assesses the error rate of the Pack-TYPE transposon finding algorithm
#
# ---input---
# potentialPacks: a list of identified potential transposons
# Genome: a DNAStringSet object containing the genome being searched
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# prints: error rate of algorithm based on known transposons
# returns: a list of correctly identified transposons
knownCACTA <- getArAthCACTA(Genome, integrityFilter) %>%
mutate(identified = start %in% potentialPacks$start & end %in% potentialPacks$end) #does not consider chromosome
#number identified
print(paste0("Correct packCACTA identified in Arabidopsis thalania: ",
(length(identifiedCACTA[,1])),
"/",
length(knownCACTA[,1])))
#detection rate
print(paste0("packCACTA detection rate: ",
round((length(identifiedCACTA[,1])/length(knownCACTA[,1])) * 100, 2),
"%"))
#error rate
print(paste0("Algorithm error rate: ",
round((1-(length(identifiedCACTA[,1])/length(potentialPacks[,1]))) * 100, 2),
"%"))
return(knownCACTA)
}
getknownTIRs <- function(knownCACTA) {
return(DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)))
}
assessSubSeq <- function(subSeq, knownTIRs, mismatch = 0) {
successfulMatches <- vector(mode = "logical", length = length(knownTIRs))
for(i in 1:length(knownTIRs)) {
if(countPattern(subSeq, knownTIRs[[i]], max.mismatch = mismatch, with.indels = TRUE) > 0) {
successfulMatches[i] <- TRUE
}
}
return(successfulMatches)
}
getBadMatches <- function(knownCACTA, subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
badCACTA <- knownCACTA[0,]
for(bad in 1:length(badMatches)) {
if(badMatches[bad] > 10) {
badMatches[bad] <- badMatches[bad] - 10
}
badCACTA <- rbind(badCACTA, knownCACTA[badMatches[bad],])
}
return(badCACTA)
}
getBadSeqs <- function(subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
return(knownTIRs[badMatches])
}
saveReport <- function(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0) {
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20]) %>%
rename(chr = Chr) %>%
select(-c(TAIR10.annotations, blast.best.hits, mobilization, chrNames)) %>%
write.csv(file = "Results/algorithmReport.csv")
return(knownCACTA)
}
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
# useful functions for manipulating and assessing other functions within the pack-TYPE
# transposon finding project
initialise <- function() {
# Loads the ArAth genome and required packages for testing
#
# ---returns---
# Arabidopsis thalania genome (as Biostrings::DNAStringSet)
library(Biostrings)
library(biomartr)
library(GenomicRanges)
library(dplyr)
Genome <- read_genome(getGenome(db = "refseq", "Arabidopsis thaliana", path = "/Input"))
return(Genome[1:5])
}
getArAthCACTA <- function(Genome, integrityFilter = NULL) {
# gets the ArAth packCACTA sequences
#
# ---input---
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# dataframe containing sequence information from the known ArAth CACTA sequences
knownCACTA <- read.csv("Input/knownCACTA.csv", sep = ";") %>%
mutate(TSD = gsub("\\*", "", TSD)) %>%
mutate(chrNames = Genome@ranges@NAMES[Chr]) %>%
mutate(forwardTIR = mapply(function(Chr, start, Genome) {
return(Genome[[Chr]][start:(start+25)])},
Chr,
start,
MoreArgs = list(Genome = Genome))) %>%
mutate(reverseTIR = mapply(function(Chr, end, Genome) {
return(reverseComplement(Genome[[Chr]][(end-25):end]))},
Chr,
end,
MoreArgs = list(Genome = Genome)))
if (is.null(integrityFilter)) {
return(knownCACTA)
} else if (integrityFilter == "complete") {
filter(knownCACTA, integrity == integrityFilter) %>%
return()
} else if (integrityFilter == "not partial") {
filter(knownCACTA, integrity != "partial") %>%
return()
}
}
algorithmAssessment <- function(potentialPacks, Genome, integrityFilter = "complete") {
# Assesses the error rate of the Pack-TYPE transposon finding algorithm
#
# ---input---
# potentialPacks: a list of identified potential transposons
# Genome: a DNAStringSet object containing the genome being searched
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# prints: error rate of algorithm based on known transposons
# returns: a list of correctly identified transposons
knownCACTA <- getArAthCACTA(Genome, integrityFilter) %>%
mutate(identified = start %in% potentialPacks$start & end %in% potentialPacks$end) #does not consider chromosome
#number identified
print(paste0("Correct packCACTA identified in Arabidopsis thalania: ",
(length(identifiedCACTA[,1])),
"/",
length(knownCACTA[,1])))
#detection rate
print(paste0("packCACTA detection rate: ",
round((length(identifiedCACTA[,1])/length(knownCACTA[,1])) * 100, 2),
"%"))
#error rate
print(paste0("Algorithm error rate: ",
round((1-(length(identifiedCACTA[,1])/length(potentialPacks[,1]))) * 100, 2),
"%"))
return(knownCACTA)
}
getknownTIRs <- function(knownCACTA) {
return(DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)))
}
assessSubSeq <- function(subSeq, knownTIRs, mismatch = 0) {
successfulMatches <- vector(mode = "logical", length = length(knownTIRs))
for(i in 1:length(knownTIRs)) {
if(countPattern(subSeq, knownTIRs[[i]], max.mismatch = mismatch, with.indels = TRUE) > 0) {
successfulMatches[i] <- TRUE
}
}
return(successfulMatches)
}
getBadMatches <- function(knownCACTA, subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
badCACTA <- knownCACTA[0,]
for(bad in 1:length(badMatches)) {
if(badMatches[bad] > 10) {
badMatches[bad] <- badMatches[bad] - 10
}
badCACTA <- rbind(badCACTA, knownCACTA[badMatches[bad],])
}
return(badCACTA)
}
getBadSeqs <- function(subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
return(knownTIRs[badMatches])
}
saveReport <- function(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0) {
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR = as.character(forwardTIR[[1]])) %>%
mutate(reverseTIR = as.character(reverseTIR[[1]])) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20]) %>%
rename(chr = Chr) %>%
select(-c(TAIR10.annotations, blast.best.hits, mobilization, chrNames))
write.csv(knownCACTA, file = "Results/algorithmReport.csv")
return(knownCACTA)
}
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 2)
View(knownCACTA)
source("R/packSearch.R")
source("R/devFunctions.R")
Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
source("R/packSearch.R")
source("R/devFunctions.R")
Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
source("R/packSearch.R")
source("R/devFunctions.R")
#Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
source("R/packSearch.R")
source("R/devFunctions.R")
Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch = 2)[1:10]
assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch = 2)[1:10]
assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch = 2)
assessSubSeq(subSeq, DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)), mismatch = 2)[1:10]
knownTIRs <- getknownTIRs(knownCACTA)
View(knownTIRs)
knownTIRs
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
View(knownCACTA)
source("R/packSearch.R")
source("R/devFunctions.R")
#Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
knownCACTA$forwardTIR[1]
knownCACTA <- algorithmAssessment(potentialPacks, Genome)
knownCACTA$forwardTIR[1]
knownCACTA$forwardTIR[1][[1]]
source("R/packSearch.R")
source("R/devFunctions.R")
#Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = 2, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
print(end-start)
source("R/devFunctions.R")
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
View(knownCACTA)
source("R/devFunctions.R")
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0)
View(knownCACTA)
View(knownCACTA)
assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]
assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch = mismatch)[1:10]
assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch = 2)[1:10]
source("R/packSearch.R")
source("R/devFunctions.R")
Genome <- initialise()
subSeq <- DNAString("CACTACAA-AAATAT") #CACTACAA-AAATAT / DNAString(consensusString(knownTIRs))
max.mismatch = 2
start <- Sys.time()
potentialPacks <- packSearch(subSeq, Genome, mismatch = max.mismatch, element.length = c(300, 3500), TSD.length = 3)
end <- Sys.time()
knownCACTA <- saveReport(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = max.mismatch)
print(end-start)
View(knownCACTA)
