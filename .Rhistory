predict(db,
DNAStringSetQuery,
BLAST_args = "-num_threads 4") %>%
return()
}
getDNAStringSetFromDataFrame <- function(dataframe, Genome) {
strings <- DNAStringSet()
for(i in 1:length(dataframe[,1])) {
strings <- c(strings, DNAStringSet(Genome[Genome@ranges@NAMES == dataframe$seqnames[i]][[1]][dataframe$start[i]:dataframe$end[i]]))
}
return(DNAStringSet(strings))
}
getBlastMatchesOnline <- function(potentialPacks, db = "nt", Genome) {
packStrings <- getDNAStringSetFromDataFrame(potentialPacks, Genome)
return(blastSeq(packStrings,
n_blast = length(packStrings),
delay_req = 20,
database="nt",
email = "jackgisby@gmail.com"))
}
x <- packBlast(potentialPacks, "nt", "online", Genome)
identifyTIRMatches <- function(TIR_Matches, subSeq, Genome, mismatch, strand = "*") {
# searches genome for potential TIRs based on sequence similarity
#
# ---input---
# TIR_Matches: dataframe of previously identified matches
# subSeq: DNAString object containing the sub-sequence to be searched for
# Genome: DNAStringSet object containing the genome to be searched
# mismatch: numeric, acceptable edit distance between subSeq and a given sequence in Genome
# strand: string, direction of match - forward (+) or reverse (-)
#
# ---returns---
# TIR_Matches: dataframe of previously identified matches and matches identified during this search
for(i in 1:length(Genome)) { #refactor without Granges?
matchData <- GRanges(seqnames = names(Genome)[i],
ranges = as(matchPattern(subSeq, Genome[[i]], max.mismatch = mismatch, with.indels = TRUE), "IRanges"),
strand = strand)
if(!is.null(matchData)) {
TIR_Matches <- rbind(TIR_Matches, as.data.frame(matchData))
}
}
return(TIR_Matches)
}
getTSDs <- function(TIR_Matches, Genome, TSD.length, direction) {
# gets the TSD sequences for potential TIR ends
#
# ---input---
# TIR_Matches: dataframe of potential TIR ends
# Genome: DNAStringSet containing the genome to be searched
# TSD.length: numeric, length of TSD region to be matched
# direction: string, forward (+) or reverse (-) strand
#
# ---returns---
# TIR_Matches dataframe with an additional column for each TIR's associated TSD sequence as a string
if(direction == "+") {
return(TIR_Matches %>% mutate(
TSD = mapply(function(seqnames, start, TSD.length, Genome) {
return(as.character(Genome[Genome@ranges@NAMES == seqnames][[1]][(start - TSD.length):(start - 1)]))},
seqnames,
start,
MoreArgs = list(TSD.length = TSD.length, Genome = Genome))
))
} else if(direction == "-") {
return(TIR_Matches %>% mutate(
TSD = mapply(function(seqnames, end, TSD.length, Genome) {
return(as.character(Genome[Genome@ranges@NAMES == seqnames][[1]][(end + 1):(end + TSD.length)]))},
seqnames,
end,
MoreArgs = list(TSD.length = TSD.length, Genome = Genome))))
}
}
identifyPotentialPackElements <- function(forwardMatches, reverseMatches, Genome, element.length) {
# identifies potential Pack-TYPE transposons by identifying neighbouring forward and reverse sequences
# and matching them together given similar neighbouring TSD sequences
#
# ---input---
# forwardMatches: dataframe containing potential forward TIR sequences
# reverseMatches: dataframe containing potential reverse TIR sequences
# Genome: DNAStringSet object containing the genome being searched
# element.length: vector of minimum and maximum length of Pack-TYPE transposons being searched for
#
# ---returns---
# dataframe of potential Pack-TYPE transposable elements
potTransposons <- as.data.frame(GRanges())
for(forwardMatch in 1:length(forwardMatches[,1])) {
forwardRepeat <- forwardMatches[forwardMatch,]
chr <- as.character(forwardRepeat[[1]])
searchRange <- c(forwardRepeat$start + element.length[1], forwardRepeat$start + element.length[2])
if(searchRange[2] > length(Genome[Genome@ranges@NAMES == chr][[1]])) {
searchRange[2] <- length(Genome[Genome@ranges@NAMES == chr][[1]])
}
reverseRepeats <- filter(reverseMatches,
seqnames == forwardRepeat$seqnames &
end > searchRange[1] &
end < searchRange[2] &
strand == "-"  &
TSD == forwardRepeat$TSD)
if(length(reverseRepeats[,1]) > 0) {
for(reverseMatch in 1:length(reverseRepeats[,1])) {
potTransposons <- rbind(potTransposons, data.frame(seqnames = forwardRepeat$seqnames,
start = forwardRepeat$start,
end = reverseRepeats[reverseMatch,]$end,
width = reverseRepeats[reverseMatch,]$end - forwardRepeat$start,
strand = "*"))
}
}
}
return(potTransposons)
}
getBlastMatches <- function(potentialPacks, db, db.loc, Genome) {
if(db.loc == "local") {
blastMatches <- list(length = length(potentialPacks))
for(i in 1:length(potentialPacks)) {
blastMatches[i] <- blastMatches[i] <- getBlastMatchesLocal(Genome[Genome@ranges@NAMES == potentialPacks$seqnames[i]][potentialPacks$start[i]:potentialPacks$end[i]],db)
}
} else if(db.loc == "online") {
blastMatches <- getBlastMatchesOnline(potentialPacks, db, Genome)
}
return(blastMatches)
}
getBlastMatchesLocal <- function(DNAStringSetQuery, db) {
predict(db,
DNAStringSetQuery,
BLAST_args = "-num_threads 4") %>%
return()
}
getDNAStringSetFromDataFrame <- function(dataframe, Genome) {
strings <- DNAStringSet()
for(i in 1:length(dataframe[,1])) {
strings <- c(strings, DNAStringSet(Genome[Genome@ranges@NAMES == dataframe$seqnames[i]][[1]][dataframe$start[i]:dataframe$end[i]]))
}
return(DNAStringSet(strings))
}
getBlastMatchesOnline <- function(potentialPacks, db = "nt", Genome) {
packStrings <- getDNAStringSetFromDataFrame(potentialPacks, Genome)
return(blastSeq(packStrings,
n_blast = length(packStrings),
delay_req = 20,
database="nt",
email = "jackgisby@gmail.com"))
}
x <- packBlast(potentialPacks, "nt", "online", Genome)
source("R/searchFunctions.R")
x <- packBlast(potentialPacks, "nt", "online", Genome)
blastMatches <- getBlastMatchesOnline(potentialPacks, db, Genome)
library(rBLAST)
blastMatches <- getBlastMatchesOnline(potentialPacks, "nt", Genome)
library(hoardeR)
blastMatches <- getBlastMatchesOnline(potentialPacks, "nt", Genome)
View(potentialPacks)
View(blastMatches)
blastMatches$res
blastMatches <- getBlastMatchesOnline(potentialPacks, "nt", Genome)
identifyTIRMatches <- function(TIR_Matches, subSeq, Genome, mismatch, strand = "*") {
# searches genome for potential TIRs based on sequence similarity
#
# ---input---
# TIR_Matches: dataframe of previously identified matches
# subSeq: DNAString object containing the sub-sequence to be searched for
# Genome: DNAStringSet object containing the genome to be searched
# mismatch: numeric, acceptable edit distance between subSeq and a given sequence in Genome
# strand: string, direction of match - forward (+) or reverse (-)
#
# ---returns---
# TIR_Matches: dataframe of previously identified matches and matches identified during this search
for(i in 1:length(Genome)) { #refactor without Granges?
matchData <- GRanges(seqnames = names(Genome)[i],
ranges = as(matchPattern(subSeq, Genome[[i]], max.mismatch = mismatch, with.indels = TRUE), "IRanges"),
strand = strand)
if(!is.null(matchData)) {
TIR_Matches <- rbind(TIR_Matches, as.data.frame(matchData))
}
}
return(TIR_Matches)
}
getTSDs <- function(TIR_Matches, Genome, TSD.length, direction) {
# gets the TSD sequences for potential TIR ends
#
# ---input---
# TIR_Matches: dataframe of potential TIR ends
# Genome: DNAStringSet containing the genome to be searched
# TSD.length: numeric, length of TSD region to be matched
# direction: string, forward (+) or reverse (-) strand
#
# ---returns---
# TIR_Matches dataframe with an additional column for each TIR's associated TSD sequence as a string
if(direction == "+") {
return(TIR_Matches %>% mutate(
TSD = mapply(function(seqnames, start, TSD.length, Genome) {
return(as.character(Genome[Genome@ranges@NAMES == seqnames][[1]][(start - TSD.length):(start - 1)]))},
seqnames,
start,
MoreArgs = list(TSD.length = TSD.length, Genome = Genome))
))
} else if(direction == "-") {
return(TIR_Matches %>% mutate(
TSD = mapply(function(seqnames, end, TSD.length, Genome) {
return(as.character(Genome[Genome@ranges@NAMES == seqnames][[1]][(end + 1):(end + TSD.length)]))},
seqnames,
end,
MoreArgs = list(TSD.length = TSD.length, Genome = Genome))))
}
}
identifyPotentialPackElements <- function(forwardMatches, reverseMatches, Genome, element.length) {
# identifies potential Pack-TYPE transposons by identifying neighbouring forward and reverse sequences
# and matching them together given similar neighbouring TSD sequences
#
# ---input---
# forwardMatches: dataframe containing potential forward TIR sequences
# reverseMatches: dataframe containing potential reverse TIR sequences
# Genome: DNAStringSet object containing the genome being searched
# element.length: vector of minimum and maximum length of Pack-TYPE transposons being searched for
#
# ---returns---
# dataframe of potential Pack-TYPE transposable elements
potTransposons <- as.data.frame(GRanges())
for(forwardMatch in 1:length(forwardMatches[,1])) {
forwardRepeat <- forwardMatches[forwardMatch,]
chr <- as.character(forwardRepeat[[1]])
searchRange <- c(forwardRepeat$start + element.length[1], forwardRepeat$start + element.length[2])
if(searchRange[2] > length(Genome[Genome@ranges@NAMES == chr][[1]])) {
searchRange[2] <- length(Genome[Genome@ranges@NAMES == chr][[1]])
}
reverseRepeats <- filter(reverseMatches,
seqnames == forwardRepeat$seqnames &
end > searchRange[1] &
end < searchRange[2] &
strand == "-"  &
TSD == forwardRepeat$TSD)
if(length(reverseRepeats[,1]) > 0) {
for(reverseMatch in 1:length(reverseRepeats[,1])) {
potTransposons <- rbind(potTransposons, data.frame(seqnames = forwardRepeat$seqnames,
start = forwardRepeat$start,
end = reverseRepeats[reverseMatch,]$end,
width = reverseRepeats[reverseMatch,]$end - forwardRepeat$start,
strand = "*"))
}
}
}
return(potTransposons)
}
getBlastMatches <- function(potentialPacks, db, db.loc, Genome) {
if(db.loc == "local") {
blastMatches <- list(length = length(potentialPacks))
for(i in 1:length(potentialPacks)) {
blastMatches[i] <- blastMatches[i] <- getBlastMatchesLocal(Genome[Genome@ranges@NAMES == potentialPacks$seqnames[i]][potentialPacks$start[i]:potentialPacks$end[i]],db)
}
} else if(db.loc == "online") {
blastMatches <- getBlastMatchesOnline(potentialPacks, db, Genome)
}
return(blastMatches)
}
getBlastMatchesLocal <- function(DNAStringSetQuery, db) {
predict(db,
DNAStringSetQuery,
BLAST_args = "-num_threads 4") %>%
return()
}
getDNAStringSetFromDataFrame <- function(dataframe, Genome) {
strings <- DNAStringSet()
for(i in 1:length(dataframe[,1])) {
strings <- c(strings, DNAStringSet(Genome[Genome@ranges@NAMES == dataframe$seqnames[i]][[1]][dataframe$start[i]:dataframe$end[i]]))
}
return(DNAStringSet(strings))
}
getBlastMatchesOnline <- function(potentialPacks, db = "nt", Genome) {
packStrings <- getDNAStringSetFromDataFrame(potentialPacks, Genome)
return(blastSeq(packStrings,
n_blast = length(packStrings),
delay_req = 20,
database="nt",
keepInMemory = TRUE,
email = "jackgisby@gmail.com"))
}
blastMatches <- getBlastMatchesOnline(potentialPacks, "nt", Genome)
View(blastMatches)
blastMatches$res
blastMatches[["res"]][[8]][["blastRes"]]
View(blastMatches)
blastMatches[["res"]][[1]][["blastRes"]]
xmls <- importXML(folder=file.path(projFolder,"hoardeROut/"))
xmls <- importXML(folder=file.path(projFolder,"hoardeROut/"))
importXML
GenomicTools.fileHandler::importXML("hoardeR-08.09.2019@18-27-13")
x <- GenomicTools.fileHandler::importXML("hoardeR-08.09.2019@18-27-13")
View(x)
x$`>1`
x[[">1"]]
View(x[[">1"]])
View(x[[">2"]])
View(x[[">3"]])
View(x[[">4"]])
View(x[[">5"]])
View(x[[">6"]])
View(x[[">7"]])
View(x[[">8"]])
View(potentialPacks)
View(x[[">4"]])
View(x[[">4"]])
x <- GenomicTools.fileHandler::importXML("hoardeR-08.09.2019@18-14-29")
View(x[[">4"]])
View(blastMatches)
View(x[[">3"]])
View(knownCACTA)
library(Biostrings)
library(biomartr)
library(GenomicRanges)
library(dplyr)
library(rBLAST)
library(hoardeR)
"1"
c(x = "a", y = "b")
subSeq <- DNAStringSet(c(1 = "CACTACAA-AAATAT",
2 = "CACTACAA-AAATAT",
3 = "CACTACAA-AAATAT",
1 = "CACTACAA-AAATA",
1 = "CACTACAA-AAA",
1 = "CACTACAA",
0 = "CACTACAA"))
c(1 = "CACTACAA-AAATAT",
2 = "CACTACAA-AAATAT",
3 = "CACTACAA-AAATAT",
1 = "CACTACAA-AAATA",
1 = "CACTACAA-AAA",
1 = "CACTACAA",
0 = "CACTACAA")
c(1 = "CACTACAA-AAATAT",
2 = "CACTACAA-AAATAT",
3 = "CACTACAA-AAATAT",
1 = "CACTACAA-AAATA",
1 = "CACTACAA-AAA",
1 = "CACTACAA",
0 = "CACTACAA")
# useful functions for manipulating and assessing other functions within the pack-TYPE
# transposon finding project
initialise <- function(genomeName = "Arabidopsis thaliana") {
# Loads the ArAth genome and required packages for testing
#
# ---returns---
# Arabidopsis thalania genome (as Biostrings::DNAStringSet)
Genome <- read_genome(getGenome(db = "refseq", genomeName, path = "/Input"))
if(genomeName == "Arabidopsis thaliana") {
return(Genome[1:5])
} else {
return(Genome)
}
}
getPotentialPackList <- function(subSeqs,
Genome,
element.length,
TSD.length) {
# gets potentialPack dataframe list for DNAStringSet
potentialPackList <- vector("list", length = length(subSeqs))
for(subSeq in 1:length(subSeqs)) {
potentialPackList[subSeq] <- packSearch(subSeq = subSeqs[subSeq],
Genome,
mismatch = subSeqs@ranges@NAMES[subSeq],
element.length = element.length,
TSD.length = TSD.length)
}
return(potentialPackList)
}
getArAthCACTA <- function(Genome, integrityFilter = NULL) {
# gets the ArAth packCACTA sequences
#
# ---input---
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# dataframe containing sequence information from the known ArAth CACTA sequences
knownCACTA <- read.csv("Input/knownCACTA.csv", sep = ";") %>%
mutate(TSD = gsub("\\*", "", TSD)) %>%
mutate(chrNames = Genome@ranges@NAMES[Chr]) %>%
mutate(forwardTIR = mapply(function(Chr, start, Genome) {
return(Genome[[Chr]][start:(start+25)])},
Chr,
start,
MoreArgs = list(Genome = Genome))) %>%
mutate(reverseTIR = mapply(function(Chr, end, Genome) {
return(reverseComplement(Genome[[Chr]][(end-25):end]))},
Chr,
end,
MoreArgs = list(Genome = Genome)))
if (is.null(integrityFilter)) {
return(knownCACTA)
} else if (integrityFilter == "complete") {
filter(knownCACTA, integrity == integrityFilter) %>%
return()
} else if (integrityFilter == "not partial") {
filter(knownCACTA, integrity != "partial") %>%
return()
}
}
algorithmAssessment <- function(potentialPacks, Genome, integrityFilter = "complete") {
# Assesses the error rate of the Pack-TYPE transposon finding algorithm
#
# ---input---
# potentialPacks: a list of identified potential transposons
# Genome: a DNAStringSet object containing the genome being searched
# integrityFilter: (optional) string, filters knownCACTA - "complete" filters for
# only complete matches whereas "not partial" filters for non-partial matches
# Genome: DNAStringSet object containing the ArAth genome
#
# ---returns---
# prints: error rate of algorithm based on known transposons
# returns: a list of correctly identified transposons
knownCACTA <- getArAthCACTA(Genome, integrityFilter) %>%
mutate(identified = start %in% potentialPacks$start & end %in% potentialPacks$end) #does not consider chromosome
#number identified
print(paste0("Correct packCACTA identified in Arabidopsis thalania: ",
(sum(knownCACTA$identified)),
"/",
length(knownCACTA[,1])))
#detection rate
print(paste0("packCACTA detection rate: ",
round((sum(knownCACTA$identified)/length(knownCACTA[,1])) * 100, 2),
"%"))
#error rate
print(paste0("Algorithm error rate: ",
round((1-(sum(knownCACTA$identified)/length(potentialPacks[,1]))) * 100, 2),
"%"))
return(knownCACTA)
}
getknownTIRs <- function(knownCACTA) {
return(DNAStringSet(c(knownCACTA$forwardTIR, knownCACTA$reverseTIR)))
}
assessSubSeq <- function(subSeq, knownTIRs, mismatch = 0) {
successfulMatches <- vector(mode = "logical", length = length(knownTIRs))
for(i in 1:length(knownTIRs)) {
if(countPattern(subSeq, knownTIRs[[i]], max.mismatch = mismatch, with.indels = TRUE) > 0) {
successfulMatches[i] <- TRUE
}
}
return(successfulMatches)
}
getBadMatches <- function(knownCACTA, subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
badCACTA <- knownCACTA[0,]
for(bad in 1:length(badMatches)) {
if(badMatches[bad] > 10) {
badMatches[bad] <- badMatches[bad] - 10
}
badCACTA <- rbind(badCACTA, knownCACTA[badMatches[bad],])
}
return(badCACTA)
}
getBadSeqs <- function(subSeq, mismatch) {
badMatches <- which(!assessSubSeq(subSeq, getknownTIRs(knownCACTA), mismatch))
return(knownTIRs[badMatches])
}
saveReport <- function(potentialPacks, subSeq, Genome, integrityFilter = NULL, mismatch = 0) {
knownCACTA <- algorithmAssessment(potentialPacks, Genome, integrityFilter = integrityFilter) %>%
mutate(forwardTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[1:10]) %>%
mutate(reverseTIR_Identified = assessSubSeq(subSeq, getknownTIRs(.), mismatch = mismatch)[11:20]) %>%
mutate(forwardTIR = mapply(function(forwardTIR) {
return(as.character(forwardTIR))},
forwardTIR)) %>%
mutate(reverseTIR = mapply(function(reverseTIR) {
return(as.character(reverseTIR))},
reverseTIR)) %>%
mutate(Chr = mapply(function(Chr) {
return(Genome@ranges@NAMES[Chr])},
Chr)) %>%
select(-c(TAIR10.annotations, blast.best.hits, mobilization, chrNames))
write.csv(knownCACTA, file = "Results/algorithmReport.csv")
return(knownCACTA)
}
getRepeatMaps <- function(Genome) {
repeatMaps <- data.frame("Chromosome" = factor(),
"Start" = integer(),
"End" = integer(),
"Name" = character(),
"Rep_Start" = integer(),
"Rep_End" = integer(),
"Orientation" = factor(),
"Identity_(%)" = double())
chr <- c("I", "II", "III", "IV", "V")
for(i in 1:length(Genome@ranges@NAMES)) {
repeatMap <- read.table(paste0("Input/AraTh_RepeatMap/ATmap", chr[[i]]))
colnames(repeatMap) <- c("Chromosome", "Start", "End", "Name", "Rep_Start", "Rep_End", "Orientation", "Identity_(%)")
repeatMap$Chromosome <- Genome@ranges@NAMES[i]
repeatMaps <- rbind(repeatMaps, repeatMap)
}
repeatMaps %>%
filter(grepl("ENSPM", Name)) %>%
makeGRangesFromDataFrame(keep.extra.columns = TRUE) %>%
return()
}
filterElements <- function(potentialPacks, repeatMaps) {
isTransposon <- vector("list", length(potentialPacks[,1]))
potentialPacksGRanges <- makeGRangesFromDataFrame(potentialPacks)
for(i in 1:length(isTransposon)) {
isTransposon[i] <- countOverlaps(potentialPacksGRanges[i], repeatMaps)
if(countOverlaps(potentialPacksGRanges[i], repeatMaps) > 0) {
isTransposon[i] <- TRUE
} else {
isTransposon[i] <- FALSE
}
}
potentialPacks$isTransposon <- isTransposon
return(potentialPacks)
}
Genome <- initialise()
library(Biostrings)
library(biomartr)
library(GenomicRanges)
library(dplyr)
library(rBLAST)
library(hoardeR)
getwd()
